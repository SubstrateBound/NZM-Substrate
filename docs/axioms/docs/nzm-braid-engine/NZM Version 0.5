NZM Technical Documentation: Version 0.5 (REFINED)Subject: The Geometry of Interaction (Discrete Gradients & Containment Fusion)Date: 2026.02.04Status: FINAL / REPO-READYFramework: NZM-Substrate (Axioms I-X)1. Executive SummaryVersion 0.5 marks the formal departure from classical physics approximations. It replaces "Empty Space" with a Deterministic Textured Substrate (Ambient Hum) and derives Gravity and Momentum as Refractive Indices within the $\Omega$-Calculus. This version introduces Structural Containment Fusion, where clusters merge based on topological compatibility, with all operations explicitly mapped to $\Omega$-operators to prevent zero-creep.2. Theoretical Foundations2.1 The Deterministic Ambient HumIn compliance with Axiom I (Non-Zero) and Axiom IX (History), the substrate is initialized with a recurring residue pattern. We reject "random" noise in favor of a Ground State Braid Word ($[1, 2, 1]$).Ground State: Every node $i$ is an $\Omega$-Triple where $\omega_\phi$ is a function of the universal history sequence.Perceived Rest: The state where an object’s internal phase-shift matches the local substrate’s refractive index ($IR_{obj} \approx IR_{amb}$).2.2 Gravity as Computational Refraction"Force" is the Refractive Index ($n_\Omega$) of the braid. Massive clusters create high-density residue gradients. Smaller clusters "bend" toward these regions because the computational cost of normalization ($\phi$) is lower in the direction of pre-existing residues (the path of least resistance).2.3 Containment-Based Fusion ($\oplus$)Collision transition into Entanglement. Using Axiom X (Self-Similarity), two clusters merge only if their scales ($\omega_s$) are topologically compatible (adjacent or harmonic multiples).Scale Fusion ($s_1 \oplus s_2$): Structural expansion of the braid width.Phase Fusion ($\phi_1 \oplus \phi_2$): Accumulation of work density/residues.3. The $\Omega$-Calculus Operator MappingTo maintain axiomatic purity, all internal logic follows these discrete mappings:Physical EventΩ-OperatorNZM Physical RealityConcatenation$\oplus$Joining strands; $max(1, a + b)$.Layering$\otimes$Increasing structural resonance/multiplication.Reduction$\ominus$Subtraction; if $\omega_\phi=1$, inject $[1,2,1]$.Normalization$\oslash$Simplification via Yang-Baxter moves.4. Refined Implementation (Python)Python"""
NZM V0.5: The Refined Geometry Engine
Implements Deterministic Hum, Refractive Movement, and Ω-Mapped Fusion.
"""

class OmegaTriple:
    def __init__(self, s, p, phi):
        self.s = s      # Scale (Strand Count)
        self.p = p      # Position (Index)
        self.phi = phi  # Phase (Residue Count + 1)

    def __repr__(self):
        return f"Ω(s:{self.s}, p:{self.p}, φ:{self.phi})"

class NZM_Substrate_V05:
    def __init__(self, size=100):
        self.size = size
        # Formalized Noise: Ground State Braid Word [1, 2, 1]
        self.nodes = [self._generate_residue_triple(i) for i in range(size)]

    def _generate_residue_triple(self, index):
        # Axiom I & IX: Deterministic residue injection (No Zero)
        residue_pattern = [1, 2, 1]
        phi_value = residue_pattern[index % 3] 
        return OmegaTriple(s=1, p=index, phi=phi_value)

    def get_refractive_index(self, pos):
        """Calculates n_Omega (The 'Gravity' or 'Stiffness' of the node)."""
        return self.nodes[pos % self.size].phi

    def resolve_movement(self, cluster):
        """Least-Work Path Movement: Veering toward higher residue density."""
        adj_nodes = [(cluster.p - 1) % self.size, (cluster.p + 1) % self.size]
        best_pos = max(adj_nodes, key=lambda x: self.get_refractive_index(x))
        cluster.p = best_pos

    def resolve_fusion(self, clusters):
        """Structural Fusion: Uses Ω-Operator Mapping for s and phi."""
        for i, c1 in enumerate(clusters):
            for j, c2 in enumerate(clusters[:]): 
                if i != j and c1.p == c2.p:
                    if self._is_compatible(c1, c2):
                        self._execute_omega_merge(c1, c2, clusters)

    def _is_compatible(self, c1, c2):
        # Axiom X: Compatibility via Scale Harmonics
        return (c1.s % c2.s == 0) or (abs(c1.s - c2.s) <= 1)

    def _execute_omega_merge(self, c1, c2, clusters):
        # Explicit Mapping to Ω-Operators
        c1.s = self._omega_plus(c1.s, c2.s)      # s1 ⊕ s2
        c1.phi = self._omega_plus(c1.phi, c2.phi) # φ1 ⊕ φ2
        
        if c2 in clusters: clusters.remove(c2)
        print(f"FUSION: Scale {c1.s} formed via Ω-Concatenation.")

    def _omega_plus(self, a, b):
        """Axiom I: Addition floored at Unity."""
        return max(1, a + b)

class PersistentCluster(OmegaTriple):
    def __init__(self, s, p, phi):
        super().__init__(s, p, phi)
        self.wake = [] # Axiom IX: Encoded History

    def tick(self, substrate):
        substrate.resolve_movement(self)
        self.wake.append(self.p)
        if len(self.wake) > 5: self.wake.pop(0)
5. Axiomatic Compliance ReportAxiom I (Non-Zero): Every node in the substrate and every cluster operation is floored at 1 via _omega_plus.Axiom VII (Bounded Interference): Fusion is gated by compatibility, preventing runaway accumulation.Axiom IX (History): Ambient density is a deterministic loop $[1, 2, 1]$, encoding the "Universal Word" into the background.Axiom X (Self-Similarity): The _is_compatible logic applies regardless of scale, ensuring fractal consistency.6. ConclusionV0.5 provides a complete mathematical environment where "Space," "Force," and "Matter" are simply different expressions of residue density within a non-zero braid. By replacing stochastic randomness with deterministic residue injection and mapping all structural changes to the $\Omega$-Calculus, we have secured the substrate against zero-creep and established a stable foundation for V0.6.
